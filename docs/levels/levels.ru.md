# Уровень переопределения (`.bem/level.js`)

На уровне переопределения должен располагаться файл конфигурации `.bem/level.js`, который содержит в себе мета-информацию об устройстве уровня, а именно:

* правила маппинга БЭМ-сущностей в файловой системе;
* технологии, определенные для уровня;
* мета-информация для системы сборки.

При создании уровня командой `bem create level`, файл `.bem/level.js` создается пустым. Это означает, что уровень *стандартный*. Поведение стандартного уровня описано в классе `Level` в файле [lib/level.js](https://github.com/bem/bem-tools/blob/master/lib/level.js).

Перекрыть поведение уровня просто. Файл `.bem/level.js` (как и практически любой файл конфигурации) является CommonJS-модулем. При обнаружении такого файла, `bem-tools` создает класс-наследник стандартного класса `Level`, используя экспорт этого модуля в качестве расширения класса (внутри используется модуль [inherit](https://github.com/dfilatov/node-inherit)).

В примере ниже перекрывается метод `getTechs()`:

```js
exports.getTechs = function() {

    return {
        'bemjson.js': ''
        'css': 'path/to/my/css-tech-module.js'
    }

};
```

## Наследование уровней

Чтобы не копировать код из одного конфига уровней в другой, вы можете выносить общие части в самостоятельные модули и наследоваться от них. Таким образом можно выстраивать целые иерархии уровней.

Чтобы задать базовый уровень, необходимо экспортировать свойство `baseLevelPath` из модуля, например:

```js
exports.baseLevelPath = require.resolve('path/to/base/level.js');
```

Уровни-наследники также можно создавать командой:

```
bem create level <your-level-name> --level path/to/base/level.js
```

## Правила маппинга БЭМ-сущностей в файловой системе

По умолчанию на уровне переопределения используется следующая схема маппинга (на примере технологии `CSS`):

```
level/
    block/
        __elem/
            _mod/
                block__elem_mod_val.css
            block__elem.css
        _mod/
            block_mod_val.css
        block.css
```

Если вас не устраивает эта схема, вы можете задать свою. Для этого нужно перекрыть соответствующие методы `match*()` и `get*()` в файле `.bem/level.js`.

## Определенные для уровня технологии

Для уровня переопределения можно задекларировать список используемых технологий. Достаточно экспортировать функцию `getTechs()`, которая должна вернуть объект, в ключах которого лежат имена технологий, а в значениях:

* абсолютный путь до технологии — будет использоваться модуль, находящийся по этому пути, или
* короткое имя технологии — будет использоваться реализация технологии с указанным именем из `bem-tools`, или
* пустая строка — будет использоваться реализация технологии по умолчанию.

По умолчанию, на уровне переопределения ни одна из технологий не определена явно. Если попытаться внутри таких уровней вызывать технологии по короткому имени (например, `css` или `js`), то будут использованы модули технологии
из состава `bem-tools`, если они существуют. Полный список таких технологий смотрите в [lib/techs](https://github.com/bem/bem-tools/tree/master/lib/techs).

Если попытаться использовать технологии, которые не задекларированы явно и которые при этом отсутствуют в `bem-tools`, будет использоваться реализация технологии по умолчанию (см. [lib/tech.js](https://github.com/bem/bem-tools/blob/master/lib/tech.js)).

Технологии, задекларированные на уровне, используются:

* командой `bem create`;
* командой `bem build`;
* для интроспекции по файловой системе (см. метод `getLevelByIntrospection()` класса `Level`);
* в процессе сборки командами `bem make` и `bem server`.

Мы рекомендуем явно декларировать все используемые технологии.

## Метаинформация для системы сборки

Во время сборки проекта командами `bem make` и `bem server`, для выполнения команды `bem build` нужна информация о том, из каких уровней переопределения необходимо собирать тот или иной бандл. Эти данные необходимо отразить в свойстве
`bundleBuildLevels` объекта, возвращаемого функцией `getConfig()`.

```js
exports.getConfig = function() {

    return extend({}, this.__base() || {}, {

        bundleBuildLevels: this.resolvePaths([
            // your levels here
        ])

    });

};
```
