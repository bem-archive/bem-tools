# Модули технологий. Создание и использование
## Общие понятия

### Технологии в БЭМ
Технологии в методологии БЭМ — это средства, с помощью которых описывается внешний вид и функциональность блока, элемента или модификатора. 

Например, в блоке «Кнопка» может быть CSS-файл, описывающий внешний вид кнопки, и JS-файл, содержащий сценарий, который выполняется при нажатии на эту кнопку.
Т.о. блок «Кнопка» реализован в технологиях CSS и JS. 

На практике в качестве технологии могут рассматриваться самые разные данные, относящиеся к БЭМ-сущности. Документация блока тоже является технологией, в которой он реализован.

### Технологии в bem-tools
Пакет [bem-tools](http://ru.bem.info/tools/bem/) — это инструментарий, позволяющий работать с проектами в БЭМ-терминах. Технология — одна из базовых идей, заложенных в архитектуру пакета. Понятие технологии в bem-tools имеет двойной смысл:
  * с одной стороны, под технологией понимается определенный тип данных, относящихся к БЭМ-сущности. В дальнейшем, будем называть их **файлами технологии**.
  * с другой, технология — это модуль Node.js, который выполняет операции над файлами или, иначе говоря, позволяет работать с файлами технологии в БЭМ-терминах. Назовем его **модулем технологии**.

Модуль технологии работает с файлами технологии соответствующего ему типа. Как правило, для каждого типа данных создается отдельный модуль технологии, определяющий, как работать с данными этого типа. 

Файлы технологии идентифицируются модулем на основании суффиксов. **Суффиксом** в bem-tools считается часть имени файла, следующая после первой точки в его названии.


### Особенности архитектуры пакета bem-tools
Для БЭМ-проектов характерен двоякий набор задач при работе с файлами технологий.

С одной стороны, для каждой БЭМ-сущности в проекте создаются отдельные файлы каждой технологии. Выше мы рассматривали эту особенность БЭМ-проектов на примере блока "Кнопка". Проект может включать сотни и даже тысячи БЭМ-сущностей, которые должны размещаться на файловой системе по определенной схеме.

Создаваемые файлы технологий удобно заполнять шаблонным содержимым. Например, модуль технологии `CSS` помещает в создаваемый файл селектор класса, соответвующий БЭМ-сущности, для которой файл был создан.

```css
.button__icon 
{
}
```

Как следствие, при работе с БЭМ-проектами пользователю постоянно приходится создавать огромное количество предзаполненных файлов и каталогов, организованных в определенную структуру. 

Для автоматизации этих задач служит команда `bem create`. Она же используется, если нужно совершить действие с единичным файлом технологии. Например,  преобразовать его в другую технологию. Так, можно создать модуль технологии, позволяющий преобразовывать PNG в JPG или XML в JSON.

С другой стороны, файлы технологий из блоков нужно собирать в бандлы для передачи браузеру, обрабатывать, минимизировать и т.п. Назовем этот процесс **сборкой**. 

**Бандл** (от англ. bundle — вязанка, пакет) — совокупность результирующих файлов технологий, собранных из файлов технологий блоков и [уровней переопределения](http://ru.bem.info/method/filesystem/). Каждый отдельный результирующий файл технологии называется **бандлом технологии**. Для файлов одной технологии в процессе сборки создается один бандл технологии.

Для сборки служит команда `bem build`. У команды есть две точки входа:
  * массив уровней переопределения, передаваемый пользователем в качестве аргумента;
  * декларации сборки.

**Декларация** — это файл с описанием БЭМ-сущностей, собираемых командой `bem build`. Подробнее о форматах декларации читайте в [приложении 2](#Приложение-2-Структура-файла-декларации-команды-bem-build).

Таким образом, двоякий набор задач, характерный для БЭМ-проектов, был реализован в архитектуре пакета bem-tools в виде команд `bem create` и `bem build`: 
  * за создание/преобразование единичных файлов технологии отвечает команда `bem create`;
  * за процесс сборки отвечает команда `bem build`.

В процессе создания модулей технологий из [всех команд](http://ru.bem.info/tools/bem/commands/), входящих в пакет bem-tools, ключевыми являются `bem create` и `bem build`. Команды `bem make` и `bem server` — это надстройки над ними. Это означает, что модули технологий, созданные для `bem create` и `bem build`, влияют и на поведение команд `bem make` и `bem server`.

Архитектура команды `bem decl` не предполагает возможности расширения с помощью модулей технологий.


Другая особенность БЭМ-проектов, повлиявшая на архитектуру bem-tools — мультилингвальность. Проект может содержать самые разные типы данных и схема их обработки может меняться от проекта к проекту. Это означает, что инструмент для работы с БЭМ-проектами должен гибко настраиваться под разные схемы обработки данных и их типы.  В bem-tools такая возможность реализована за счет отделения модулей технологии от базовой технологии.

**Базовая технология** — это Node.js модуль, реализующий наиболее общую схему обработки данных командами `bem create` и `bem build`. В базовую технологию bem-tools заложены:
  * схема размещения сущностей на файловой системе; 
  * принцип именования БЭМ-сущностей;
  * базовый набор файловых операций. При вызове команд `bem create` и `bem build` с произвольным именем технологии `FOO` в качестве опции, команда `bem create` будет создавать для БЭМ-сущностей пустые файлы с расширением `.foo`. Команда `bem build` будут собирать FOO-файлы бандлов технологии, в которых отдельными строками будут прописаны пути к FOO-файлам блоков.

Помимо этого, базовая технология предоставляет API для модулей технологии. Используя методы API, модули технологии реализуют дополнительную функциональность, необходимую для работы с соответствующими типами данных.

В пакет bem-tools входит ряд [готовых](https://github.com/bem/bem-tools/tree/master/lib/techs) модулей технологий — **стандартные модули технологий**. С их помощью реализована поддержка наиболее востребованных в БЭМ-проектах технологий, таких как CSS или JS и часть функциональности пакета — работа с зависимостями бандла, создание уровней переопределения и т.п.

Стандартные модули технологий удобно использовать как пример при создании собственных модулей. Кроме того, любой из стандартных модулей может быть использован как основа для новой технологии.
Подробнее о стандартных модулях можно узнать из [Приложения 1.](Приложение-1-Перечень-стандартных-модулей-технологий)


##Модули технологий


Модули технологий определяют поведение команд `bem create` и `bem build`. Они добавляют к функциональности bem-tools возможность работы с новыми типами данных. 
Модули технологий позволяют: 
  * расширить и переопределить поведение базовой технологии;
  * расширить и переопределить поведение готовой технологии (другого модуля технологии).

Причем сделать это можно на заданном уровне переопределения, не затрагивая поведение данной технологии на других уровнях.

Можно рассматривать команды `bem create` и `bem build` как независимые подпрограммы, каждая из которых предоставляет собственный API. Модуль технологии — адаптер, реализующий API команд `bem create` и `bem build`. 


###Принцип работы
Пользователь вызывает команду `bem create` или `bem build`, передает ей [набор параметров](http://ru.bem.info/tools/bem/commands/) и в качестве опции ```-t, --tech``` (```-T, --force-tech```) — названия технологий, используя которые эти команды нужно выполнить. 

Команда создает экземпляр объекта технологии, у которого вызывается один из методов API. Для команды `bem create` вызывается метод `createByDecl(item, level, opts)`, для команды `bem build` — `buildByDecl(decl, levels, output)`.

После этого начинает работать модуль соответствующей технологии. Механизм его действия зависит от того, какие методы API объекта технологии были переопределены в модуле.


###Задачи, решаемые модулями технологий

####Создание и преобразование файлов технологий


Шаблон файлов, создаваемых командой `bem create`, определяется модулем технологии. Модуль задает:
  * суффикс создаваемых файлов;
  * данные, которые будут записаны в них при создании.

Кроме статических данных в шаблоне может использоваться контекст, относящийся к создаваемой БЭМ-сущности. Под контекстом здесь понимается содержимое переменной `vars`. Переменная `vars` конструируется на начальном этапе выполнения базовой технологии команды `bem create` и доступна из всех ее методов. В ней содержится хеш опций, относящихся к текущей БЭМ-сущности, создаваемой командой `bem create`:

```js
  {
opts: { args: [массив аргументов], force: true // перезаписывать существующие файлы},
  BlockName: 'имя_блока',
  Prefix: 'префикс_пути_создаваемой_БЭМ-сущности',
  ElemName: 'имя_элемента',
  ModName: 'имя_модификатора',
  ModVal: 'значение_модификатора'
  }
  ```

**Префикс** — это путь и имя файла без суффикса. Например, для файла `project/block/file.js` префиксом будет `project/block/file`.

Наряду с контекстом, в шаблоне может использоваться и другой источник данных. Например, данные могут быть получены из сетевого репозитория, базы данных, системы контроля версий и т.д.

####Сборка и обработка файлов технологий

Сборка и обработка файлов технологий производятся командой `bem build`. К наиболее типичным задачам, решаемым командой, относятся:
  * сборка бандла технологии из отдельных файлов этой технологии, находящихся внутри блоков;
  * преобразование исходных файлов нескольких технологий в бандл одной общей технологии;
  * обработка исходных файлов технологии перед включением их в бандл.

Для команды `bem build` модуль технологии определяет:
  * суффиксы исходных и результирующих файлов;
  * действия, производимые над содержимым обрабатываемых файлов;
  * способ преобразования декларации, на основании которой производятся действия с файлами. В базовой технологии преобразований декларации не осуществляется, однако такая возможность заложена в API.


###Размещение
Пользовательские модули технологий рекомендуется размещать в каталоге `.bem/techs`, находящемся в корневом каталоге проекта или уровня переопределения. Стандартные модули технологий bem-tools находятся в каталоге `lib/techs` пакета (см. [репозиторий](https://github.com/bem/bem-tools/tree/master/lib/techs)).

Для модуля технологии можно задать произвольный путь размещения в файловой системе. Тем не менее, лучше использовать рекомендованные пути размещения. Это сделает структуру вашего проекта более наглядной. К тому же, в новых версиях bem-tools предполагается реализация автоматического подключения модулей технологий, размещенных по рекомендованным путям.


###Подключение
Чтобы подключить к проекту или уровню переопределения свой модуль технологии `FOO`, нужно зарегистрировать его в файле `.bem/level.js`. Этот файл должен экспортировать функцию `getTechs()`, которая возвращает объект. В ключах этого объекта содержатся имена технологий, а в значениях — пути до модулей технологий, используемых на текущем уровне переопределения.

```js
exports.getTechs = function() {
    return {
        'foo': require.resolve('путь/до/модуля/технологии/foo.js')
    };
}; 

```



Отметим, что функция `require.resolve()` проверяет наличие файла модуля технологии по указанному пути. Если бы путь был задан, в виде `'foo': 'путь/до/модуля/технологии/foo.js'`, то при отсутствии файла по указанному пути поведение технологии будет идентично базовой.



##Создание модуля технологии
Основных пути создания модулей технологии два: можно расширять базовую технологию, реализованную в модуле `lib/tech.js`, или взять за основу готовый модуль технологии.

Для организации наследования в bem-tools используется модуль [inherit](https://github.com/dfilatov/node-inherit). Как следствие, во всех описанных ниже способах, из методов можно обратиться к объекту технологии через `this`, а через ```this.__base(...)``` можно вызвать метод одного из базовых классов. К классу технологии можно обратиться через ```this.__class```.

###На основе базовой технологии
Модуль, создаваемый на основе базовой технологии, должен экспортировать объект `techMixin`. Методы этого объекта переопределят методы базового класса `Tech`.  

```js
exports.techMixin = {

    getCreateResult: function(...) {
        // ваш код
    } };
    
```

###На основе готовой технологии
Использовать готовый модуль технологии как основу можно двумя способами: задав имя технологии или указав путь к ее модулю. Рассмотрим эти способы подробнее.

####По имени
Для использования технологии по имени, нужно экспортировать переменную `baseTechName`, присвоив ей имя расширяемой технологии.
Этот способ используется для организации контекстного наследования. Базовый класс будет выбран в зависимости от настроек уровня переопределения, на котором будет использован модуль технологии.

**Этот способ подходит для случаев:**
  * когда нужно расширить технологию, для которой есть несколько различных реализаций. Такой способ позволяет изменить и доопределить поведение технологии в целом, сохраняя конкретные особенности ее реализаций.
 
```js

exports.baseTechName = 'CSS';
exports.techMixin = { /* ... /* };

```


В этом примере новая технология будет расширять технологию `CSS`, заданную на уровне переопределения в файле `.bem/level.js`.
Если на уровне переопределения технология `CSS` не задана, будет расширена базовая технология `CSS` из набора стандартных модулей технологий пакета bem-tools.

####По пути

Чтобы взять за основу готовый модуль технологии по пути, нужно добавить к экспортируемым функциям переменную `baseTechPath`. В ней задается абсолютный путь до расширяемого модуля.

**Этот способ подходит для случаев:**
  * когда вы не хотите зависеть от реализаций данной технологии, заданных на уровне переопределения. Например, если есть модуль технологии, поведение которого отличается от стандартного, и нужно быть уверенным, что расширяться будет именно он.
  * когда одну пользовательскую технологию расширяют с помощью другой. Например, если существует модуль технологии, обладающий некоторой базовой функциональностью, которую в разных проектах удобно расширять специфическим для проекта набором правил.

```js
var BEM = require('bem');
exports.baseTechPath = BEM.require.resolve('./techs/CSS');
exports.techMixin = { /* ... /* };
```

## Работа с API v2 базовой технологии 

В пакете bem-tools с версии 0.6.4 было обновлено API базовой технологии, используемое при написания модулей технологий. В дальнейшем будем называть обновленное API базовой технологии v2, а старое v1. 

Изменения затронули только API базовой технологии команды `bem build` и команд, использующих `bem build` в ходе выполнения (например `bem make`).

В новой версии bem-tools реализована обратная совместимость с модулями технологий, использующими API v1. Тем не менее, новая версия API позволяет ускорить сборку проекта командами `bem make` и `bem server`. Прирост скорости зависит от специфики проекта и может варьироваться в диапазоне от нескольких процентов до десятка раз. 

Чтобы ускорить сборку вашего проекта, нужно использовать модули технологий, реализующие новую версию API.

Для начала работы с обновленным API рекомендуется воспользоваться версией [project-stub](https://github.com/bem/project-stub/tree/v2), использующей API v2.

При расширении одного модуля технологии другим все модули в цепочке наследования должны использовать API одной версии (старые не должны перемешиваться с новыми). 

###Стандартные модули технологий и API v2
В новой версии bem-tools был добавлен набор стандартных модулей технологий, поддерживающих  API v2. Таким образом, в пакете имеется два набора стандартных модулей -- v1 и v2. Для использования стандартных модулей технологии c поддержкой API v2 нужно декларировать их в файле `.bem/level.js` проекта. Например:
```js
exports.getTechs = function() {

    return {
        'bemjson.js'     : '',
        'js'             : 'v2/js-i',
        'bemdecl.js'     : 'v2/bemdecl.js',
        'deps.js'        : 'v2/deps.js',
        'i18n'           : '../bem-bl/blocks-common/i-bem/bem/techs/v2/i18n.js'),
        'i18n.js'        : '../bem-bl/blocks-common/i-bem/bem/techs/v2/i18n.js.js'),
        'css'            : 'v2/css'
    };
};
```

Если в файле level.js проекта или уровня переопределения стандартные модули технологий задекларированы не были, то по умолчанию будет использоваться API v1. Для использования новой версии API, путь до стандартных модулей технологий v2 должен быть задан явно, как показано в примере выше.

Модули технологий, использующие API v1 будут работать с новой версией bem-tools без прироста скорости. Это относится как к готовым модулям технологий, идущих в составе ``bem-tools``, так и к тем, которые входят в библиотеку `bem-bl`.

Версия bem-bl, предназначенная для использования с API v2 находится [здесь](https://github.com/bem/bem-bl/tree/0.3).

###Кеширование сборки
Использование в проекте модулей технологии v2 позволяет повысить производительность сборки за счет кеширования уровней переопределения и блоков.

Если в вашем проекте подключается `bem-bl` или другая библиотека блоков, блоки которой вы не меняете, а редактируете на других уровнях переопределения, то сборку можно настроить таким образом, чтобы библиотека просканировалась единожды, и при последующих сборках использовался кеш с диска.

Сделать это можно с помощью следующего кода в `.bem/make.js`
```js
MAKE.decl('Arch', {
    getLevelCachePolicy: function() {
        return {
                cache: false,
                except: ['bem-bl']
        }
    }

});
```

Здесь `cache:false` означает, что по умолчанию кеш уровней выключен.
А `except` — массив путей уровней или блоков, для которых будет действовать исключение, т.е. в данном случае кеш будет включен.

Кеш регенерируется, если сборка запущена с опцией `--force`.


### Настройка модуля технологии для использования нового API
Чтобы в модуле технологии включить поддержку API v2, модуль должен экспортировать свойство API_VER:

```js
exports.API_VER = 2;

exports.techMixin = {

...

};
```

### Настройка работы с суффиксами

В старой версии API для указания суффиксов, с которыми работает модуль технологии, использовались методы: `getSuffixes()`, `getBuildSuffixes()`. В API v2 эти методы сохранились, но для большей гибкости при работе с суффиксами рекомендуется использовать метод `getBuildSuffixesMap()`. Этот метод позволяет указать как суффиксы собираемых файлов технологии, так и суффиксы файлов бандла технологии. Кроме того он позволяет модулю технологии собирать файлы технологии с несколькими суффиксами.

```js
{
    getBuildSuffixesMap: function() {
        return {
            'ie.css': ['ie.css', 'ie.hover.css'];
        }
    }
}

```

Код из примера будет собирать файл бандла с суффиксом `ie.css` из файлов технологий с суффиксами `ie.css` и `ie.hover.css`.
Ключей в возвращаемом объекте может быть больше одного, если модуль технологии собирает несколько файлов бандла с разными суффиксами.

### Валидация файлов при последующих сборках
При повторных сборках проекта часто возникает ситуация, когда собираемые файлы уже присутствуют в результирующем каталоге сборки. В таких ситуациях требуется валидация файлов -- определение, нужно ли пересобрать файл, или тот что уже есть на диске актуален.

В API v1 проверкой валидности собираемого файла занималась команда `bem make`, точнее - код в BemBuildNode. 
В API v2 эта задача переложена на модули технологий. Модуль может самостоятельно проверить валидность собираемых файлов, опираясь на знания об исходных и результирующих суффиксах файлов технологии. В случае если модуль не осуществляет валидацию, результирующий файл по умолчанию будет пересобираться.

В большинстве случаев для валидации достаточно логики, заложенной в базовую технологию v2. Если ваш модуль технологии производит сборку файлов на основе суффиксов из `getBuildSuffixesMap()` и не подмешивает в результирующий файл сторонний контент, то, вероятнее всего, писать специальную логику для валидации нет необходимости.

В базовой технологии v2 логика валидации реализована в методе `getBuildResults(decl, levels, output, opts)`. Чтобы определить, нужно ли вызывать `getBuildResult(files, suffix, output, opts)` (т.е. непосредственно собрать файл с данным build-суффиксом), метод получает список файлов, которые должны попасть в сборку. Затем `getBuildResults(decl, levels, output, opts)` проверяет возвращаемое значение метода `validate(file, filteredFiles, opts)`. При значении true файл считается валидным и не пересобирается.

Метод `validate(file, filteredFiles, opts)` принимает следующие параметры:  

* {String} `file` - абсолютный путь собираемого файла.  
* {Array} `filteredFiles` - список файлов, которые должны попасть в сборку.  
* {Object} `opts` - хеш опциональных параметров, сюда передается аргумент `opts`, приходящий в `getBuildResults(decl, levels, output, opts)`.  
Если в opts содержится ключ `force` со значением `true`, метод `validate(file, filteredFiles, opts)` вернет `false`.  
Метод `validate(file, filteredFiles, opts)` загружает из кеша (.bem/cache) список файлов, из которых в последний раз собирался результирующий файл и сравнивает его со значением параметра `filteredFiles`. Если отличий нет, считается, что результирующий файл валиден.

Для получения списка файлов попавших в предыдущую сборку используется метод `getLastUsedData(file)`, для сохранения в кеш - `saveLastUsedData(file, data)`. Параметр `file` - это абсолютный путь до файла, кеш которого нужно загрузить или сохранить, `data` - объект со списком файлов, который запишется в кеш в виде JSON.


##Рекомендации по созданию модулей технологий
###Общие рекомендации
В процессе создания модуля технологии, нужно отдельно описать поведение базовой технологии для команд `bem create` и `bem build`. 

Чтобы изменить поведение базовой технологии, нужно в создаваемом модуле переопределить один или несколько методов, из стандартной цепочки вызовов базовой технологии. 

Ниже приводится перечень методов, рекомендованных для переопределения. Некоторые из них специально включены в цепочку вызовов, чтобы упростить интеграцию модулей в базовую технологию.

Среди рекомендованных есть несколько **методов-хелперов**. Это служебные методы, используемые для решения типовых задач. Например, для работы с суффиксами. Эти методы могут отсутствовать в цепочке вызовов базовой технологии.

С полным перечнем методов API v1 базовой технологии  можно ознакомиться в [исходном коде](https://github.com/bem/bem-tools/blob/master/lib/tech/v1.js).


###Методы, рекомендованные для переопределения
####Для команды bem create

#####create(prefix, vars, force)
**Аргументы:** 
  * {String} `prefix` — префикс создаваемого файла технологии.
  * {Object} `vars` — словарь, содержащий сведения о создаваемой БЭМ-сущности - имя блока, элемента, модификатора, значение модификатора, префикс.
  * {Boolean} `force` —  булева переменная, определяющая, нужно ли перезаписывать создаваемые файлы, если они уже существуют.
**Возвращаемое значение:**  Промис со значением Undefined в случае успешного выполнения метода, промис с ошибкой в случае неудачи. 

**Описание:** Метод отвечает за общий процесс формирования и сохранения содержимого создоваемых файлов технологий. 
**Когда переопределять:** В случаях, когда нужно радикально изменить процесс выполнения базовой технологии. Например, добавить промежуточные этапы или исключить из цепочки вызовов определенные методы.

**Поведение в базовой технологии:** Метод формирует содержимое создаваемых файлов технологий для всех суффиксов с помощью метода `getCreateResults(prefix, vars)`, затем сохраняет его на диске с помощью `storeCreateResult(path, suffix, res, force)`.


#####getCreateSuffixes() 
**Аргументы:** -

**Возвращаемое значение:** {Array} Суффиксы создаваемых файлов.

**Описание:** Позволяет настроить работу с суффиксами для команды `bem create`. 

**Когда переопределять:** Если нужно, чтобы команды `bem create` и `bem build` работали с разными суффиксами. Например, когда команда `bem build` должна собирать из блоков файлы с несколькими суффиксами, а команда #bem create# должна создавать файлы технологии с одним определенным суффиксом.

**Поведение в базовой технологии:** Возвращает массив с одним элементом — суффиксом технологии.

**Пример:** Содержание листинга взято из модуля технологии `JS+COFFE`. Этот модуль технологии собирает из блоков файлы, написанные на CoffeeScript и JavaScript в общий бандл технологии. При этом CoffeeScript транслируется в JavaScript.  
Модуль технологии работает с исходными файлами с двумя суффиксах — `js` и `coffee`, а бандл технологии собирается с общим суффиксом `js`.

```js 
exports.techMixin = {

    getSuffixes: function() {
        return ['js', 'coffee'];
    },

    getCreateSuffixes: function() {
        return ['coffee'];
    } }
```

Как видно из примера, при вызове команды `bem create`, файл технологии будет создан с суффиксом `coffee`.


#####getCreateResult(path, suffix, vars)
**Аргументы:** 
  * {String} `path` — полный путь до файла, включая имя и расширение.
  * {String} `suffix` — суффикс создаваемого файла.
  * {String} `vars` — словарь контекста, содержащий сведения о создаваемой БЭМ-сущности.

**Возвращаемое значение:** {String} Промис с содержимым создаваемого файла.

**Описание:** Метод отвечает за формирование содержимого файла с текущим суффиксом.

**Когда переопределять:** Когда нужно задать содержимое файла, создаваемого командой `bem create`.

**Поведение в базовой технологии:** Возвращает промис с пустой строкой.

**Пример:** CSS-селектор 
Этот метод используется в модуле стандартной технологии `CSS`. Там с помощью `vars` конструируется селектор класса, соответствующий создаваемой БЭМ-сущности. Команда `bem create block -T CSS b-my-block` создаст файл со следующим содержимым:

```css
.b-my-block
{
}
```

В модуле технологии `CSS` метод переопределен следующим образом:

```js
export.techMixin = {

    getCreateResult: function(path, suffix, vars) {

        vars.Selector = '.' + vars.BlockName +
            (vars.ElemName? '__' + vars.ElemName : '') +
            (vars.ModVal? '_' + vars.ModName + '_' + vars.ModVal : '');

        return Template.process([
            '{{bemSelector}}',
            '{',
            '}'],
            vars);

    } }
```


####Для команды bem build

#####build(prefixes, outputDir, outputName)
**Аргументы:** 
  * {Array} `prefixes` — промис с массивом префиксов исходных файлов технологии. Префикс каждого из собираемых файлов технологии записывается в массив отдельной строкой.
  * {Array} `outputDir` — каталог, в котором собирается бандл технологии.
  * {String} `outputName` — имя собираемого бандла технологии.

**Возвращаемое значение:** Промис со значением Undefined в случае успешного выполнения метода, промис с ошибкой в случае неудачи. 

**Описание:** Метод определяет основной порядок выполнения базовой технологии `bem build`. 

**Когда переопределять:** В случаях, когда нужно радикально изменить процесс выполнения базовой технологии. Например, добавить промежуточные этапы или исключить из цепочки вызовов определенные методы.

**Поведение в базовой технологии:** С помощью метода `getBuildResults(prefixes, outputDir, outputName)` формирует объект результатов сборки `res`, который затем передает методу `storeBuildResults(prefix, res)` для сохранения.


#####transformBuildDecl(decl)
**Аргументы:**
  * {Object} `decl` — исходная декларация сборки.

**Возвращаемое значение:** {Object} промис с преобразованной декларацией.

**Описание:** Метод предназаначен для трансформации входной декларации сборки.

**Когда переопределять:** В случаях, когда нужно совершать какие-либо манипуляции с входной декларацией сборки. 

**Поведение в базовой технологии:** Метод возвращает промис со входной декларацией. Никаких изменений декларации не производится.

**Пример:** В качестве примера можно рассмотреть стандартный модуль технологии deps.js. Здесь с помощью метода `transformBuildDecl(decl)` декларация сборки сериализуется и из нее рекурсивно строится граф зависимостей бандла технологии. 

```js 
transformBuildDecl: function(decl) {

        return this.expandDeps(decl)
            .then(function(deps) {

                var d = deps.serialize(),
                    o = {};

                if(d['']) {
                    o.deps = d[''][''];
                    delete d[''][''];
                }
                U.isEmptyObject(d) | (o.depsByTechs = d);

                return o;

            });

    },
```


#####getBuildSuffixes()
**Аргументы:** -

**Возвращаемое значение:** {Array} Суффиксы.

**Описание:** Позволяет настроить работу с суффиксами для команды `bem build`. 

**Когда переопределять:** Если нужно, чтобы команды `bem create` и `bem build` работали с разными суффиксами. Например, когда из блочных файлов технологии с одним суффиксом должен собираться бандл технологии с другим.

**Поведение в базовой технологии:** Возвращает массив с одним элементом — суффиксом технологии, для которой производится сборка бандла технологии.


#####getBuildResult(prefixes, suffix, outputDir, outputName)
**Аргументы:** 
  * `prefixes` — {Array} промис с массивом префиксов, для которых осуществляется сборка бандла.
  * `suffix` — {String} суффикс бандла технологии.
  * `outputDir` — {String} путь к каталогу, в котором создается бандл.
  * `outputName` — {String} имя файла бандла без суффикса.

**Возвращаемое значение:** {String} промис с содержимым бандла технологии для текущего суффикса.

**Описание:** Метод отвечает за сборку содержимого бандла для текущего суффикса. 

**Когда переопределять:** Когда нужно производить действия с содержимым бандла технологии. Например, изменить порядок включения фрагментов, полученных из исходных файлов, или поместить весь бандл технологии внутрь какой-нибудь конструкции. Например, HTML-код внутрь тегов `<html>` ... `</html>`.

**Поведение в базовой технологии:** На основании префиксов и суффикса метод создает массив путей собираемых файлов. Проверяет, существуют ли файлы из массива. Запускает для существующих файлов метод `getBuildResultChunk(relPath, path, suffix)`, формирующий фрагмент содержимого бандла для текущего файла. Накапливает результаты выполнения метода `getBuildResultChunk(relPath, path, suffix)` в переменной `res[suffix]` и возвращает ее в виде промиса.

**Пример:** В качестве примера рассмотрим модуль технологии [xml.js](https://github.com/eprev/eprev.github.io/blob/5bc7b59a3f396b4ab05f39b480f46a71879fb32b/.bem/techs/xml.js). Метод `getBuildResult(prefixes, suffix, outputDir, outputName)` переопределен в модуле таким образом, что отдельные фрагменты данных помещаются в конструкцию `<fest:template xmlns:fest="http://fest.mail.ru">` ... `</fest:template>`, задающую пространство имен XML.

```js    
getBuildResult: function (prefixes, suffix, outputDir, outputName) {
        return Q.when(this.__base(prefixes, suffix, outputDir, outputName), function (chunks) {
            return Template.process([
                '<fest:template xmlns:fest="http://fest.mail.ru">',
                chunks.join('\n'),
                '    <fest:include src="' + outputName  + '.page.xml" />',
                '</fest:template>'
            ]);
        });
    },
```


#####getBuildResultChunk(relPath, path, suffix)
**Аргументы:** 
  * `relPath` — {String} относительный путь до обрабатываемого файла технологии.
  * `path` — {String} абсолютный путь до обрабатываемого файла технологии.
  * `suffix` — {String} суффикс обрабатываемого файла технологии.
  
**Возвращаемое значение:** {String} фрагмент данных, относящихся к обрабатываемому файлу.

**Описание:** Метод служит для формирования фрагмента данных, относящихся к одному исходному файлу. 

**Когда переопределять:** Переопределяйте этот метод, когда нужно производить манипуляции с содержимым исходных файлов технологии перед его записью в файл бандла. Метод позволяет решать следующие задачи:
  * импортировать содержимое исходного файла технологии;
  * возвращать пути до исходного файла технологии;
  * обрамлять содержимое или пути в какую-нибудь конструкцию (см. пример ниже);
  * производить различные действия для исходных файлов с разными суффиксами.

**Поведение в базовой технологии:** Возвращает строку, содержащую относительный путь до обрабатываемого файла.

**Пример:** Технология `CSS` из набора стандартных модулей использует этот метод для того, чтобы поместить путь к CSS-файлу в конструкцию ```@import url('...')```.

```js
exports.techMixin = {

    getBuildResultChunk: function(relPath, path, suffix) {
        return '@import url(' + relPath + ');\n';
    } };
```


####Общие методы команд bem create и bem build


#####getSuffixes() 
**Аргументы:** -

**Возвращаемое значение:** {Array} Суффиксы.

**Описание:** Метод-хелпер. Позволяет настроить работу с суффиксами для команд `bem create` и `bem build`. 

**Когда переопределять:** В простых случаях, если нужно, чтобы команды `bem create` и `bem build` работали с одним общим суффиксом.

**Поведение в базовой технологии:** В цепочке вызовов базовой технологии метод вызывается через `getBuildSuffixes()` и `getCreateSuffixes()`. Для `getBuildSuffixes()` возвращает массив суффиксов исходных файлов, участвующих в сборке. Для `getCreateSuffixes()` возвращает массив суффиксов создаваемых файлов. 

**Пример:** Модуль технологии `JS` из набора стандартных модулей создает и собирает из блоков файлы с суффиксом `js`. По этому для работы с суффиксами модулю достаточно переопределить метод `getSuffixes()`. 

```js
exports.techMixin = {

    getSuffixes: function() {
        return ['js'];
    }

};
```

#####getDependencies()
**Аргументы:** -

**Возвращаемое значение:** {Array} массив технологий, от которых зависит данная.

**Описание:** Метод-хелпер. Предоставляет список зависимостей в виде массива бандлов технологий, от которых зависит сборка данного бандла технологии. Используется `bem make / server` для построения графа зависимостей.

**Когда переопределять:** В случаях, когда собираемый бандл технологии зависит от другой технологии того же бандла. 

**Поведение в базовой технологии:** Отсутствует в стандартной цепочке вызовов.

**Пример:** Для примера рассмотрим модуль технологии `bemdecl.js` из набора стандартных модулей технологии. Технология ищет файл `имя_сущности.bemjson.js` и преобразует его в `имя_сущности.bemdecl.js`. Для корректной работы модулю необходим бандл технологии `bemjson.js`.

```js
exports.techMixin = {

    getDependencies: function() {
        return ['bemjson.js'];
    }

};
```

#### Изменения сигнатур методов в базовом классе технологии API v2

| v1        | v2           |
| ------------- |-------------|
|buildByDecl(decl, levels, output)|buildByDecl(decl, levels, output, opts)|
|getBuildResult(prefixes, suffix, outputDir, outputName)|getBuildResult(files, suffix, output, opts)|
|getBuildResults(prefixes, outputDir, outputName)|getBuildResults(decl, levels, output, opts)|
|getBuildPrefixes(decl, levels)|:x:|
|build(prefixes, outputDir, outputName)|:x:|
|filterPrefixes(prefixes, suffixes)|:x:|
|:x:|getBuildSuffixesMap() |
|:x:|getBuildPaths(decl, levels)|
|:x:|saveLastUsedData(file, data)|
|:x:|getLastUsedData(file)|

 * Аргумент `opts`, во всех методах где он встречается, представляет собой хеш параметров, переданных команде `bem build`.
 В него же можно добавлять свои вспомогательные параметры.
 * Вместо пары аргументов `outputDir` и `outputName` во все методы где они использовались передается один аргумент — `output`. Он содержит путь без суффикса к файлу (файлам) бандла технологии.
 * Вместо аргумента `prefixes`, содержащего пути к собираемым файлам технологий, потенциально существующим на уровнях переопределения или в блоках, методу `getBuildResult(files, suffix, output, opts)` передается аргумент `files`. Это массив файлов, которые *фактически* существуют по путям с которых производится сборка и имеют суффиксы, соответствующие собираемой технологии. Элемент массива - это объект со свойствами:

		* file — имя файла.
		* absPath — абсолютный путь до файла.
		* lastUpdated — дата модификации файла.
		* suffix — суффикс файла.

 * Метод `getBuildPaths()` по переданной декларации `decl` и списку уровней переопределения `levels` возвращает список фактически существующих файлов, попадающих под декларацию. Список возвращается методом в виде хеша, в котором файлы сгруппированы по суффиксу технологии. Например:

```js
{
    css: [{...}, {...}, {...}],
    js: [{...}, {...}],
    bemhtml: [{...}, {...}, {...}, {...}]
}
```

 * Парные методы`saveLastUsedData(file, data)`/`getLastUsedData(file)` позволяют сохранить/загрузить список файлов, из которых технология  строила файл бандла `file` в последний раз. Метод `getLastUsedData(file)`может быть использован для валидации сборки. Он позволяет определить, нужно ли заново пересобирать файл бандла, или же существующий валиден, так как был построен из тех же файлов, которые участвуют в текущей сборке.


##Приложения
 
###Приложение 1. Перечень стандартных модулей технологий

####bemdecl.js.js
**Команда:** `bem create`

**На входе:** файл `имя_сущности.bemjson.js` 

**На выходе:** `имя_сущности.bemdecl.js`

**Описание:** При запуске команды `bem create` модуль ищет файл `имя_сущности.bemjson.js` и преобразует его в `имя_сущности.bemdecl.js`. Файл `bemjson.js` это декларация, описывающая структуру страницы (БЭМ-дерево). Файл `bemdecl.js` содержит набор уникальных БЭМ-сущностей в рамках собираемого бандла. Каждая сущность записывается в файл `bemdecl.js` в порядке их следования в `bemjson.js`.

####blocks.js
**Команда:** `bem create`

**На входе:** -

**На выходе:** уровень переопределения `имя_сущности.blocks/`

**Описание:** Модуль технологии служит хелпером для команды `bem create level`. Используется для создания уровеня переопределения со ссылкой на прототип `.bem/levels/blocks.js`. При вызове команды `bem create -b desktop -t blocks` будет создан каталог уровня переопределения `desktop.blocks`. 

####bundles.js
**Команда:** `bem create`

**На входе:** -

**На выходе:** уровень переопределения `имя_сущности.bundles/`

**Описание:** Работает аналогично `blocks.js`. Используется для создания уровеня для бандлов со ссылкой на прототип `.bem/levels/bundles.js`. При вызове команды `bem create -b desktop -t bundles` будет создан каталог уровня переопределения `desktop.bundles`.

####examples.js
**Команда:** `bem create`

**На входе:** -

**На выходе:** уровень переопределения `имя_сущности.examples/`

**Описание:** Работает аналогично `bundles.js`. Используется для создания уровеня для примеров со ссылкой на прототип `.bem/levels/examples.js`. При вызове команды `bem create -b button -t examples` будет создан каталог уровня переопределения `button.examples`.

####project.js
**Команда:** `bem create`

**На входе:** -

**На выходе:** каталог проекта с набором подкаталогов

**Описание:** Создает стартовую структуру проекта. В каталоге проекта модуль создает каталоги `.bem`, `.bem/techs` и `.bem/levels`. В каталоге `.bem` создается файл `level.js` со ссылкой на прототип `bem/lib/levels/project.js`. В каталоге `.bem/levels` модуль создает уровни переопределения `blocks.js`, `bundles.js` и `examples.js`. 

####level.js
**Команда:** `bem create`

**На входе:** -

**На выходе:** каталог уровня переопределения

**Описание:** Создает уровень переопределения со стандартными настройками (без прототипа).

####css.js
**Команда:** `bem create` / `bem build`

**На входе:** `.css` файлы блоков, декларация бандла

**На выходе:** `имя_сущности.css`

**Описание:** Для команды `bem create` создает CSS-файл с прописанным селектором класса, соответствующим создаваемой БЭМ-сущности и фигурными скобками с новой строки.
```css
.блок__элемент_модификатор_значение
{
}
```
Для команды `bem build` создает результирующий CSS-файл с перечнем импортов CSS-файлов блоков вида ```@import url (путь/до/файла/БЭМ-сущности.css)```.

####ie.css.js
**Команда:** `bem create` / `bem build`

**На входе:** `.ie.css` файлы блоков

**На выходе:** `имя_сущности.ie.css`

**Описание:** Модуль предназначен для создания и работы с таблицами стилей для различных версий Internet Explorer. Для команды `bem create` создает CSS-файл с прописанным селектором класса, соответствующим создаваемой БЭМ-сущности. Для команды `bem build` создает результирующий ie.css-файл с перечнем импортов ie.css-файлов блоков. В него, выше импортов ie.css-файлов блоков, включается импорт результирующего CSS-файла собираемого бандла.

####ie6.css.js
**Команда:** `bem create` / `bem build`

**На входе:** `.ie6.css` файлы блоков

**На выходе:** `имя_сущности.ie6.css`

**Описание:** Расширяет функциональность модуля `ie.css.js`. Модуль действует аналогично `ie.css.js`, но импорты `ie6.css` помещаются ниже импортов `ie.css` и `css`.

####ie7.css.js
**Команда:** `bem create` / `bem build`

**На входе:** `.ie7.css` файлы блоков

**На выходе:** `имя_сущности.ie7.css`

**Описание:** Расширяет функциональность модуля `ie.css.js`. Модуль действует аналогично `ie.css.js`, но импорты `ie7.css` помещаются ниже импортов `ie.css` и `css`.

####ie8.css.js
**Команда:** `bem create` / `bem build`

**На входе:** `.ie8.css` файлы блоков

**На выходе:** `имя_сущности.ie8.css`

**Описание:** Расширяет функциональность модуля `ie.css.js`. Модуль действует аналогично `ie.css.js`, но импорты `ie8.css` помещаются ниже импортов `ie.css` и `css`.

####ie9.css.js
**Команда:** `bem create` / `bem build`

**На входе:** `.ie9.css` файлы блоков

**На выходе:** `имя_сущности.ie9.css`

**Описание:** Действует идентично `ie.css.js`. Разница только в суффиксе создаваемых/обрабатываемых файлов.

####less.js
**Команда:** `bem create` / `bem build`

**На входе:** `.less` файлы блоков

**На выходе:** `имя_сущности.less`

**Описание:** Расширяет функциональность модуля `css.js`. Модуль действует аналогично `css.js`, но для команды `bem build` конструкция импорта имеет вид ```@import url("путь/до/файла/имя_сущности.less")```.

####sass.js
**Команда:** `bem create` / `bem build`

**На входе:** `.sass` файлы блоков

**На выходе:** `имя_сущности.sass`

**Описание:** Расширяет функциональность модуля `css.js`. Модуль действует аналогично `css.js`, но для команды `bem build` конструкция импорта имеет вид `@import путь/до/файла/имя_сущности.sass`.

####styl.js
**Команда:** `bem create` / `bem build`

**На входе:** `.styl` файлы блоков

**На выходе:** `имя_сущности.styl`

**Описание:** Расширяет функциональность модуля `css.js`.  Для команды `bem build` конструкция импорта имеет вид `@import "путь/до/файла/имя.styl"`, а для команды `bem create` первая фигурная скобка создается в той же строке, что и селектор.
```css
.блок__элемент_модификатор_значение {
}
```

####deps.js.js
**Команда:** `bem create` / `bem build`

**На входе:** `.deps.js` файлы блоков

**На выходе:** `имя_сущности.deps.js`

**Описание:** Модуль предназначен для работы с зависимостями блока. Команда `bem create` создает шаблон с пустыми массивами `mustDeps` и `shouldDeps`.
```js
({
    mustDeps: [],
    shouldDeps: []
})
```
При вызове команды `bem build` модуль считывает deps.js-файлы блоков, рекурсивно раскрывает записанные в них зависимости, сериализует полученные данные и записывает их в результирующий deps.js-файл бандла. При этом зависимости типа `mustDeps` помещаются перед той сущностью, которая от них зависит.

####js.js
**Команда:** `bem create` / `bem build`

**На входе:** `.js` файлы блоков

**На выходе:** `имя_сущности.js`

**Описание:** Для команды `bem create` модуль работает идентично базовой технологии. При вызове командой `bem build` модуль технологии собирает содержимое всех js-файлов проекта в результирующий JS-файл.

####js-i.js
**Команда:** `bem create` / `bem build`

**На входе:** `.js` файлы блоков

**На выходе:** `имя_сущности.js`

**Описание:** Для команды `bem create` модуль работает идентично базовой технологии. Команда `bem build` собирает ссылки на js-файлы блоков в результирующий JS-файл, для дальнейшей обработки программой [borschik](http://github.com/bem/borschik). Ссылки имеют вид `/*borschik:include:путь/до/файла/имя_сущности.js*/;`.

####dir.js
**Команда:** `bem create`

**На входе:** -

**На выходе:** `имя_сущности.dir/`

**Описание:** Создает каталог. Перед использованием следует связать технологию с осмысленным имененем в файле `.bem/level.js`, например:
```js
exports.getTechs = function() {

    return {
        'data': 'dir'
    };

};
```


### Приложение 2. Структура файла декларации команды bem build

Файл декларации может записываться иерархически или в виде плоского списка.
Запись плоским списком, помимо структуры, позволяет задать последовательность сборки — блоки включаются в сборку строго в том же порядке, в котором они перечислены в декларации. 

#### Структурированный вид записи
```js
exports.blocks = [{
    name: 'first-block',      // имя блока
    mods: [{                  // модификаторы блока
       name: 'mod1',          // имя модификатора блока
       vals: ['1', '2']       // значения модификатора блока
    }],
    elems: [{                 // элементы блока
        name: 'elem1',        // имя элемента блока
        mods: [{              // модификаторы элемента
            name: 'mod1',     // имя модификатор элемента
            vals: ['1', '2']  // значения модификатора элемента
        }]
    }]
}];
```

#### Плоский список
```js
exports.deps = [
    {
        block: 'first-block',  // имя блока
        elem: 'elem1',         // имя элемента блока
        mod: 'mod2',           // имя модификатора элемента
        val: '1'               // значение модификатора элемента
    },
    {
        block: 'second-block', // имя блока
        mod: 'mod3',           // имя модификатора блока
        val: '2'               // значение модификатора блока
    }
];
```


###Приложение 3. Базовая технология bem-tools

Базовая технология в bem-tools реализована в классе `Tech` в модуле `bem/lib/tech.js`. Все модули технологий расширяют этот класс и доопределяют его методы. 

Для команд `bem create` и `bem build` поведение базовой технологии различно. Рассмотрим действие каждой из команд отдельно.

####Базовая технология команды bem create
Команда `bem create` служит для создания БЭМ-сущностей.

#####На входе
При вызове, команде `bem create` могут передаваться следующие параметры:

|**Параметр** | **Описание** | **Влияет на** | **Тип** | **Обязательный**  | **Определяет**  | **Аргумент точки входа** |
| ------------- |-------------|------------- |-------------|------------- |-------------|-------------|
| [-T .. -t .. -n ..] | Параметры технологии. -T Только заданная технология. -t Заданная технология добавляется к стандартным. -n Исключает определенную технологию. | Суффиксы создаваемых файлов и выбор модуля технологии.  | Массив  | Нет (будут созданы технологии по умолчанию) | Массив технологий  | opts |
| -b | Имя блока | Префикс создаваемого файла | Строка | Да | Массив сущностей  | item |
| -l | Уровень переопределения, на котором создается сущность | Префикс создаваемого файла | Строка | Нет | Массив сущностей  | level |
| [-e .. [-m .. [-v ..]]] | Параметры БЭМ-сущности. -e Элементы блока. -m Модификаторы блока или элемента. -v Значения модификаторов блока или элемента. | Префикс создаваемого файла | Массив | Нет  | Массив сущностей  | opts |


#####Схема действия базовой технологии
Действие базовой технологии можно разделить на следующие этапы:

1. **Подготвительный этап**
```
createByDecl(item, level, opts)  // Преобразование входных данных
```

2. **Основной этап**
``` 
create(prefix, vars, force) §    // Запуск основного процесса создания сущности
```
2.1. **Формирование содержимого**
```
getCreateResults(prefix, vars) // Формирует содержимое файлов для всех создаваемых суффиксов
      getCreateSuffixes() § // Формирует массив суффиксов создаваемых файлов
      getCreateResult(path, suffix, vars) § // Формирует содержимое файла для отдельного суффикс
```
2.2. **Сохранение содержимого**
```
storeCreateResults(prefix, res, force) // Сохраняет на диске содержимое файлов для всех создаваемых суффиксов 
      getCreateSuffixes() // Создает массив суффиксов
      storeCreateResult(path, suffix, res, force)  // Сохраняет на диске содержимое файла для одного суффикса. Проверяет, существует ли создаваемый файл.
```

§ Метод, рекомендованный для переопределения.

#####Подготовительный этап
На основании входных параметров определяется массив создаваемых сущностей. 
Для каждого элемента из массива сущностей определяется массив технологий, в которых данная сущность должна быть реализована. 
Затем для каждой технологии из массива создается экземпляр объекта технологии, у которого вызывается метод `createByDecl(item, level, opts)`.

######Точка входа
На этом этапе начинает работать модуль технологии, в данном случае, базовой. Вызывается метод `createByDecl(item, level, opts)`.
Метод конструирует из входных параметров `item` и `level` префикс создаваемого файла. Далее, из данных, содержащихся в `opts`, создает объект `vars` - это словарь, содержащий сведения о создаваемой БЭМ-сущности и префикс.


######Основной этап
За процесс формирования и записи содержимого создаваемых файлов отвечает метод `create(prefix, vars, force)`.
Сначала содержимое создаваемых файлов формируется с помощью метода `getCreateResults(prefix, vars)`, затем для его сохранения вызывается метод `storeCreateResults(prefix, res, force)`.

**NB:** Метод `create(prefix, vars, force)` может быть переопределен для изменения общей схемы действия команды.

######Формирование содержимого
Метод `getCreateResults(prefix, vars)` формирует содержимое всех создаваемых файлов. Для этого он с помощью метода `getCreateSuffixes()` создает массив суффиксов. На основании префикса и суффикса, `getCreateResults(prefix, vars)` вычисляет полный путь до создаваемого файла `path`. После чего для каждого элемента массива суффиксов вызывается метод `getCreateResult(path, suffix, vars)`, который создает содержимое для этого элемента.

Результаты выполнения метода `getCreateResult(path, suffix, vars)` возвращаются в виде промиса и сохраняются в объекте `res`. В ключах этого объекта лежат суффиксы создаваемых файлов, а в значениях — содержимое этих файлов.

**NB:** Метод может быть переопределен для изменения содержимого создаваемого файла технологии.

######Сохранение содержимого
За сохранение данных из объекта res на диске отвечает метод `storeCreateResults(prefix, res, force)`. 

Метод последовательно обрабатывает все пары ключ-значение из объекта `res`. Для каждой пары вызывается метод `storeCreateResult(path, suffix, res, force)`.

Метод `storeCreateResult(path, suffix, res, force)` проверяет, существует ли создаваемый файл по пути, содержащемся в аргументе `path`. Если файл не существует, вызывается метод `save(path, res[suffix])`, который создает файл в соответствии со значением аргумента `path` и записывает в него содержимое аргумента `res` для текущего суффикса.

Если же файл по указанному пути существует, то проверяется значение аргумента `force`. Аргумент `force` — это булева переменная, получаемая из входного параметра `opts`. При значении `true` файл будет перезаписан.

####Базовая технология команды bem build
Команда `bem build` предназначена для сборки файлов технологии с уровней и из блоков в общий бандл технологии. Сборка производится на основании файла декларации и массива уровней переопределения, передаваемого пользователем.

**ВАЖНО:** По умолчанию собирается один результирующий файл для каждой технологии. Существуют модули технологий, которые работают с файлами технологии блоков с несколькими суффиксами, но бандл технологии при этом создается с одним общим суффиксом. 

#####На входе
При вызове команде `bem build` может передаваться следующий набор параметров:

|**Параметр** | **Описание** | **Влияет на** | **Тип** | **Обязательный** | **Аргумент точки входа** |
| ------------- |-------------|------------- |-------------|------------- |-------------|
| -d | Путь до файла декларации сборки | Зависимости блоков, процес сборки | Объект | Да | decl |
| -o -n | Альтернативный вариант записи пути к результирующим файлам. -o Каталог -n Имя файла | Префикс создаваемых файлов | Строки | Нет | output |
| -t  | Название технологии или полный путь до модуля технологии | Суффиксы собираемых и создаваемых файлов, выбор модулей технологии. | Строка  | Нет | - |
| -b | Имя создаваемого блока | Префикс создаваемых файлов | Строка | Да | output |
| -L | Уровень переопределения, на котором создается блок (бандл) с результирующими файлами | Префикс создаваемых файлов | Строка | Нет | output |
| -l .. -l .. | Уровни переопределения, с которых собираются БЭМ-сущности. Перечисляются в той последовательности, в которой нужно подключать БЭМ-сущности с этих уровней. | Последовательность сборки. Результат. | Массив | Нет | levels |
| [-e .. [-m .. [-v ..]]] | Параметры БЭМ-сущности. -e Элементы блока. -m Модификаторы блока или элемента. -v Значения модификаторов блока или элемента. | Префикс создаваемых файлов | Массив | Нет  | output |

#####Схема действия базовой технологии
Процесс исполнения модуля базовой технологии можно разделить на следующие этапы:

1. **Подготвительный этап**
```
buildByDecl(decl, levels, output)  // Преобразование входных аргументов
  transformBuildDecl(decl) §   // Преобразование декларации. По умолчанию, возвращает файл декларации в неизменном виде.
  getBuildPrefixes(decl, levels)   // Формирование массива префиксов исходных файлов на основании декларации и массива уровней переопределения.
```
    
2. **Основной процесс сборки**   
``` 
 build(prefixes, outputDir, outputName) §    // Запуск основного процесса сборки
```
2.1. **Формирование  результатов сборки**
```   
getBuildResults(prefixes, outputDir, outputName)   // Формирование общего объекта результатов
    getBuildSuffixes()  // Создание массива суффиксов
    getBuildResult(prefixes, suffix, outputDir, outputName) §   // Формирование результата для одного суффикса
     filterPrefixes(prefixes, suffixes) // Создание массива путей, проверка наличия исходных файлов на диске
     getBuildResultChunk(relPath, path, suffix) §   // Получение фрагмента содержимого для одного исходного файла
```
2.2. **Сохранение  результатов сборки**        
```
   storeBuildResults(prefix, res)   // Сохранение всех результатов
    getBuildSuffixes()  // Создание массива суффиксов. Аналогично этапу 2.1
    storeBuildResult(path, suffix, res)   // Сохранение результатов для одного суффикса
```
§ Метод, рекомендованный для переопределения.

#####Подготвительный этап
На подготовительном этапе происходит преобразование входных аргументов из БЭМ-терминов в формат, принимаемый методом `build(prefixes, outputDir, outputName)`.

######Точка входа
Работа базовой технологии `bem build` начинается с вызова метода `buildByDecl(decl, levels, output)`.  Этому методу передается:
 * декларация, по которой должна производиться сборка файлов технологий;
 * массив уровней переопределения, с которых производится сборка;
 * префикс бандла технологий.

На этом этапе из префикса бандла технолоии `output` конструируются переменные `outputDir` и `outputName`, содержащие имя создаваемого файла и каталог, в котором он создается.

######Работа с декларацией сборки
Затем вызывается метод `transformBuildDecl(decl)`, которому передается декларация сборки. Метод возвращает промис с декларацией. По умолчанию,  декларация возвращается без изменений. Метод встроен в цепочку вызовов как вспомогательный для удобства работы с декларацией. 

**NB:** Метод может быть использован, если нужно производить преобразования декларации сборки.

######Формирование массива префиксов
На основании декларации `decl`, полученной от метода `transformBuildDecl(decl)`, и массива уровней переопределения `levels` формируется массив префиксов собираемых файлов. В дальнейшем, на основании массива префиксов и массива суфиксов будут определены файлы, которые попадут в сборку.


#####Основной процесс сборки
За общий процесс формирования и записи содержимого результирующих файлов отвечает метод `build(prefixes, outputDir, outputName)`. 

Для этого сначала вызывается метод `getBuildResults(prefixes, outputDir, outputName)`, а затем данные, полученные при его выполнении, передаются методу `storeBuildResults(prefix, res)`, сохраняющему их в результирующий файл.

**NB:** Переопределяйте этот метод, когда нужно изменить общую схему выполнения базовой технологии - добавить или исключить этапы, изменить порядок выполнения.


######Формирование  результатов сборки
Выполнение метода `getBuildResults(prefixes, outputDir, outputName)`, отвечающего за формирование результатов сборки, происходит в три этапа. 

На первом этапе выполняется метод `getBuildSuffixes()`, который возвращает массив суффиксов исходных файлов.

На втором этапе производится итерация по всем элементам массива суффиксов. Для каждого элемента массива вызывается метод `getBuildResult(prefixes, suffix, outputDir, outputName)`. 
Метод возвращает промис с данными для записи в результирующий файл с текущим суффиксом.

**ПОДРОБНОСТИ:** Процесс формирования  результатов сборки для суффикса
Сначала на основе массива префиксов и текущего суффикса формируется массив путей `paths`. На этом этапе происходит проверка наличия файлов на диске. В массив путей попадают только существующие файлы.

Затем для каждого элемента массива `paths` вызывается метод `getBuildResultChunk(relPath, path, suffix)`, который возвращает фрагмент содержимого для текущего файла. По умолчанию возвращается строка с путем до исходного файла технологии.

**NB:** Переопределяйте этот метод, когда нужно производить манипуляции с содержимым исходных файлов технологии, перед записью в бандл технологии.

На третьем этапе из фрагментов данных для каждого суффикса формируется объект `res`, содержащий массив результатов сборки. Объект `res` возвращается методом `getBuildResults(prefixes, outputDir, outputName)` в виде промиса. В ключах этого объекта лежат суффиксы создаваемых файлов, а в значениях — содержимое этих файлов.

######Сохранение  результатов сборки
За сохранение результатов сборки отвечает метод `storeBuildResults(prefix, res)`.  
Для каждого элемента массива суффиксов вызывается метод `storeBuildResult(path, suffix, res)`. Этот метод сохраняет содержимое объекта res для текущего суффикса.

**ВАЖНО:** Сохранение производится безусловно. Если создаваемые файлы уже существуют на диске, они будут перезаписаны. 

#### Стандартный ход выполнения методов базовой технологии с API v2

![схема](http://img-fotki.yandex.ru/get/9259/127846884.247/0_b0604_843e6646_XXL.png)

Для API v2 базовой технологии команды `bem build` точкой входа по прежнему является метод `buildByDecl(decl, levels, output, opts)`. Он вызывает `getBuildResults(decl, levels, output, opts)`, результат работы которого - это хеш, где ключом служит суффикс собираемых файлов технологии, а значением - массив строк содержимого соответствующих файлов. Например, для технологии `i18n.js` он может выглядеть так:
```js
{
 'en.js': ['...', '...', ...],
 'ru.js': ['...', '...', '...', ...],
 'tr.js': ['...', '...', ...]
}
```

Этот хеш передается методу `storeBuildResults(prefix, res)`, который сохраняет его содержимое массива в файлы бандла технологии с соответствующим суффиксом.

Чтобы построить хеш, метод `getBuildResults(decl, levels, output, opts)` получает список собираемых файлов, используя вспомогательный метод `getBuildPaths(decl, levels)`. В список попадают файлы которые:

* во первых, фактически существуют на уровнях переопределения и в блоках с которых производится сборка. 
* во вторых, имеют суффиксы, соответствующие тем, которые определены в методе `getBuildSuffixesMap()` модуля технологии. 

После этого для каждого суффикса (в случае с технологией`i18n.js` это `en.js`, `ru.js` и т.д) вызывается `getBuildResult(files, suffix, output, opts)`. Ему передается список файлов, отфильтрованный по конкретному суффиксу.

Каждый путь файла обрабатывается методом `getBuildResultChunk(relPath, path, suffix)`, который на выходе формирует строку содержимого для текущего файла. В зависимости от особенностей технологии это может быть как путь до собираемого файла, обернутый в директиву подключения, так и содержимое этого файла.
